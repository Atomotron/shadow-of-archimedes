<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <script src="math32.js"></script>
    <script src="shadercompiler.js"></script>
    <script src="imageloader.js"></script>
    <script src="sounds.js"></script>
    <script src="canvasmanager.js"></script>
    <script src="dynamicvao.js"></script>
    <script src="scene.js"></script>
    <script src="engine.js"></script>
    <script src="nightdaysprite.js"></script>
    <script src="man.js"></script>
</head>
<body style="background-color:#000000;padding:0px;margin:0px;">
<div id="canvas-container" style="height:99vh; width:100%"></div>

<script id="shader-background-v" type="x-shader/x-vertex">
attribute vec2 vertex;
varying vec2 world_coord;
varying float daytime;
uniform mat3 inverse_view;
uniform vec2 solar_vector;

void main() {
    gl_Position = vec4(vertex,0.0,1.0);
    world_coord = (inverse_view * vec3(vertex,1.0)).xy;
    daytime = dot(world_coord,solar_vector);
}
</script>

<script id="shader-background-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 world_coord;
varying float daytime;
uniform float planet_radius;
uniform sampler2D gradient;
void main() {
    float r = length(world_coord)/planet_radius;
    float darkness = 1.0/(r*r);
    float texture_index = r + 0.25*smoothstep(0.5-0.0005,0.5+0.0005,0.5*r)-0.125;
    gl_FragColor = darkness*texture2D(gradient,vec2(texture_index,daytime+0.5));
}
</script>

<script id="shader-planet-disc-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 world_coord;
varying float daytime;
uniform float planet_radius;
uniform sampler2D gradient;
void main() {
    float texture_index = 0.5*length(world_coord)/planet_radius;
    float step = smoothstep(0.5-0.0001,0.5+0.0001,texture_index);
    texture_index += 0.25*step-0.125;
    float alpha = 1.0-step;
    gl_FragColor = vec4(texture2D(gradient,vec2(0.1,daytime+0.5)).xyz,1.0)*alpha;
}
</script>

<script id="shader-nightday-sprite-v" type="x-shader/x-vertex">
uniform vec2 solar_vector;
uniform mat3 view;
attribute vec2 vertex;
attribute vec3 model_x;
attribute vec3 model_y;
attribute vec3 model_z;
attribute vec3 uv_x;
attribute vec3 uv_y;
attribute vec3 uv_z;
attribute vec3 variant_mask; // Used to access sprite variants
attribute float layer;
varying vec2 uv;
varying float daytime;
varying float layer_level;
varying vec3 mask; // Used to access sprite variants
void main() {
    mat3 model = mat3(model_x,model_y,model_z);
    vec3 pos = model * vec3(vertex,1.0);
    daytime = dot(pos.xy,solar_vector);
    gl_Position = vec4((view*pos).xy,0.5,1.0);
    mask = variant_mask;
    layer_level = layer;
    uv = (mat3(uv_x,uv_y,uv_z) * vec3(vertex,1.0)).xy;
}
</script>

<script id="shader-nightday-sprite-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 uv;
varying float daytime;
uniform sampler2D gradient; // Day/night - layer gradient
uniform sampler2D spritesheet;
varying float layer_level; // Used for the background/foreground color gradient
varying vec3 mask; // Used to access sprite variants

const float ALPHA_WIDTH = 0.2;
void main() {
    vec4 sheet_color = texture2D(spritesheet,uv);
    float alpha = smoothstep(0.5-ALPHA_WIDTH, 0.5+ALPHA_WIDTH, dot(sheet_color.xyz,mask));
    vec3 base_color = texture2D(gradient,vec2(layer_level,daytime+0.5)).xyz;
    gl_FragColor = vec4(base_color*alpha,alpha);
}
</script>
<script>

// Planet
const PLANET_RADIUS = 24;
const MAN_RADIUS = PLANET_RADIUS-0.02;
const CAMERA_RADIUS = PLANET_RADIUS+0.75;
const NICE_ZONE_SIZE = 48;
const ZONE_SPEED = 0.03;
const ZONE_STARTING_ANGLE = 0.4; //Radians

// Man
const MAN_SPEED = 2;
const MAN_WALK_SATISFACTION_RANGE = 0.1;
const MAN_GRAVITY = -2;
const MAN_JUMP_VEL = 1.5;

// Camera
const CAMERA_SPEED = MAN_SPEED*1.2;
const ZOOM_SPEED = 0.25;
const MIN_ZOOM = 0.04;
const MAX_ZOOM = 0.5;
/*
 * A custom render pass that uses the custom shaders
 */
class BackgroundPass extends RenderPass {
    constructor(gl,scene,program,gradient,planet_radius) {
        super(gl,program);
        this.planet_radius = planet_radius;
        this.scene = scene;
        this.gradient = gradient;
        this.vao = new SimpleVAO(gl,program,scene.square_vao);
        this.inverse_view_loc = gl.getUniformLocation(program,"inverse_view");
        this.planet_radius_loc = gl.getUniformLocation(program,"planet_radius");
        this.gradient_loc = gl.getUniformLocation(program,"gradient");
        this.solar_loc = gl.getUniformLocation(program,"solar_vector");
        this.inverse_view = new Mat();
        this.t = 0;
    }
    update(scene,dt) {
        Mat.Inv(this.inverse_view,scene.view);
        this.t += dt;
    }
    draw(gl) {
        gl.useProgram(this.program);
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(this.gradient_loc, 0);
        gl.bindTexture(gl.TEXTURE_2D, this.gradient);
        gl.uniformMatrix3fv(this.inverse_view_loc,false,this.inverse_view.a);
        gl.uniform1f(this.planet_radius_loc,this.planet_radius);
        gl.uniform2fv(this.solar_loc,this.scene.solar_vector.a);
        this.vao.draw(gl);
    }
}

/* An object that can either 
class PhysicsItem


/* Container class for clickable regions as used by the engine object.*/
class Clickable {
    constructor(x,r,callback) {
        this.r = r;
        this.x = x;
        this.callback = callback;
    }
}
class ArchimedesEngine extends Engine {
    setup() {
        // Clickable region management
        this.clickables = new Set();
        window.addEventListener('click',(e) => {
            let nearest = null;
            let nearest_r = null;
            const dr = new Vec();
            for (const clickable of this.clickables) {
                const r = dr.eq(clickable.x).subeq(this.mouse_pos).abs();
                if (r <= clickable.r) {
                    if (nearest_r === null || nearest_r > r) {
                        nearest = clickable;
                        nearest_r = r;
                    }
                }
            }
            if (nearest !== null) {
                nearest.callback();
            }
        });
        // Background pass
        this.backgroundpass = new BackgroundPass(this.gl,
            this.scene,
            this.sc.programs.get('background'),
            this.il.textures.get('planet_sky'),
            PLANET_RADIUS,
        );
        this.scene.addPass(this.backgroundpass,1.0);
        // Background sprite pass
        this.ndspritepass = new NightdaySpritePass(this.gl,
            this.scene,
            this.sc.programs.get('nightday_sprites'),
            this.il.textures.get('gradient'),
            this.il.textures.get('mountainbiome'),
        );
        this.scene.addPass(this.ndspritepass,0.75);
        // Disc pass
        this.plantdiscpass = new BackgroundPass(this.gl,
            this.scene,
            this.sc.programs.get('planet_disc'),
            this.il.textures.get('planet_sky'),
            PLANET_RADIUS,
        );
        this.scene.addPass(this.plantdiscpass,0.5);
        // Animated sprite pass
        this.aspritepass = new AnimatedSpritePass(this.gl,
            this.scene,
            this.sc.programs.get('nightday_sprites'),
            this.il.textures.get('gradient'),
            this.il.textures.get('animations'),
        );
        this.scene.addPass(this.aspritepass,0.25);
        // Colored overlay sprite class
        this.spritepass = new SpritePass(this.gl,
            this.scene,
            this.sc.programs.get('sprite'),
            this.il.textures.get('animations'),
        );
        this.scene.addPass(this.spritepass,0.125);
        
        // Generate background
        
        function find_layer(map,folder) {
            const names = [];
            for (const [key,value] of map) {
                if (key.includes("/"+folder+"/")) {
                    names.push(key);                
                }
            }
            return names;
        }
        const bsprites = find_layer(this.il.model_frames,"Background");
        const msprites = find_layer(this.il.model_frames,"Midground");
        const fsprites = find_layer(this.il.model_frames,"Foreground");
        const biomes = ["MountainBiome","AridBiome"];
        const that = this;
        this.bgsprites = [];
        function gen_layer(sprites,layer,rdelta) {
            let angle = 0;
            while (angle < Math.PI*2.0) {
                const biome = biomes[Math.floor(0.5 * angle / Math.PI * biomes.length)];
                angle += 0.1*Math.random();
                let found = false;
                let name = ""
                while (!found) {
                    let idx = Math.floor(Math.random()*sprites.length);
                    idx = idx >= sprites.length ? sprites.length-1 : idx;
                    name = sprites[idx];
                    found = !name.includes(biome+"/");
                }
                const flags = Math.floor(Math.random()*7.0+1);
                if (flags < 1) flags = 1;
                if (flags > 7) flags = 7;
                const sprite = new NightdaySprite(that,that.ndspritepass,name,flags,layer);
                sprite.pos.polareq(PLANET_RADIUS+rdelta,angle);
                that.bgsprites.push(sprite);
            }
        }
        gen_layer(bsprites,0.0,-0.3);
        gen_layer(msprites,0.33,-0.3);
        gen_layer(fsprites,0.66,-0.3);
        // Create man 
        this.man = new Man(this,this.aspritepass);
        this.t = 0;
        // Set up camera and zoom control
        window.addEventListener('wheel',(e) => {
            const factor = Math.exp(-0.25*Math.sign(e.deltaY));
            let new_zoom = that.zoom*factor;
            if (new_zoom < MIN_ZOOM) new_zoom = MIN_ZOOM;
            if (new_zoom > MAX_ZOOM) new_zoom = MAX_ZOOM;
            that.zoom_target = new_zoom;
            that.zoom = new_zoom;
        });
        this.camera_pos = new Vec(CAMERA_RADIUS,0.0);
        this.zoom = 0.01;
        this.zoom_target = 0.25;
    }
    update(dt) {
        super.update(dt);
        this.t += dt;
        this.scene.solar_vector.polareq(1/NICE_ZONE_SIZE,ZONE_STARTING_ANGLE-Math.PI*0.5-ZONE_SPEED*this.t);
        const dr_target = this.man.target.sub(this.camera_pos);
        const dr_man = this.man.pos.sub(this.camera_pos);
        this.camera_pos.addeq(dr_man.mul(dt*CAMERA_SPEED));
        this.camera_pos.addeq(dr_target.mul(dt*CAMERA_SPEED));
        this.camera_pos.mapabseq((r) => CAMERA_RADIUS);
        this.zoom += ZOOM_SPEED*(this.zoom_target-this.zoom)*dt;
        
        let T = new Mat().translationeq(this.camera_pos.mul(-1));
        let R = new Mat().rotationeq(Math.atan2(this.camera_pos.y,this.camera_pos.x)-Math.PI*0.5);
        let S = new Mat();
        
        S.a[0] = this.zoom;
        S.a[4] = this.zoom*this.cm.aspectRatio;
        this.scene.view.eq(T);
        Mat.Compose(this.scene.view, R, this.scene.view);
        Mat.Compose(this.scene.view, S, this.scene.view);
    }
}

const engine = new ArchimedesEngine(
    canvas_container = document.getElementById("canvas-container"),
    shader_programs = {
        background:['shader-background-v','shader-background-f'],
        planet_disc:['shader-background-v','shader-planet-disc-f'],
        nightday_sprites:['shader-nightday-sprite-v','shader-nightday-sprite-f'],
    },
    images = {
        gradient:'images/gradient.png',
        planet_sky:'images/planet_sky.png',
        mountainbiome:'images/mountainbiome.png',
        animations: 'images/Animations.png',
    },    
    frames = {
        mountainbiome:'images/mountainbiome.json',
        animations: 'images/Animations.json',
    },
    music = {
        //"negentropy": "sound/Chad_Crouch_-_Negentropy.mp3"
    },
    sfx = {
        "stone_walk1": "sounds/stone_walk1.mp3",
        "stone_walk2": "sounds/stone_walk2.mp3",
        "stone_walk3": "sounds/stone_walk3.mp3",
        "stone_walk4": "sounds/stone_walk4.mp3",
        "stone_walk5": "sounds/stone_walk5.mp3",
    },
);

</script>

</div>
</body>
</html>
