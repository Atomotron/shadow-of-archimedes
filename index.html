<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <script src="math32.js"></script>
    <script src="shadercompiler.js"></script>
    <script src="imageloader.js"></script>
    <script src="sounds.js"></script>
    <script src="canvasmanager.js"></script>
    <script src="dynamicvao.js"></script>
    <script src="scene.js"></script>
    <script src="engine.js"></script>
    <script src="nightdaysprite.js"></script>
    <script src="physics.js"></script>
    <script src="man.js"></script>
    <script src="item.js"></script>
    <script src="machine.js"></script>
</head>
<body style="background-color:#000000;padding:0px;margin:0px;">
<div id="canvas-container" style="height:99vh; width:100%"></div>

<script id="shader-background-v" type="x-shader/x-vertex">
attribute vec2 vertex;
varying vec2 world_coord;
varying float daytime;
uniform mat3 inverse_view;
uniform vec2 solar_vector;

void main() {
    gl_Position = vec4(vertex,0.0,1.0);
    world_coord = (inverse_view * vec3(vertex,1.0)).xy;
    daytime = dot(world_coord,solar_vector);
}
</script>

<script id="shader-background-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 world_coord;
varying float daytime;
uniform float planet_radius;
uniform sampler2D gradient;
void main() {
    float r = length(world_coord)/planet_radius;
    float darkness = 1.0/(r*r);
    float texture_index = r + 0.25*smoothstep(0.5-0.0005,0.5+0.0005,0.5*r)-0.125;
    gl_FragColor = darkness*texture2D(gradient,vec2(texture_index,daytime+0.5));
}
</script>

<script id="shader-planet-disc-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 world_coord;
varying float daytime;
uniform float planet_radius;
uniform sampler2D gradient;
void main() {
    float texture_index = 0.5*length(world_coord)/planet_radius;
    float step = smoothstep(0.5-0.0001,0.5+0.0001,texture_index);
    texture_index += 0.25*(step-0.5);
    float alpha = 1.0-step;
    gl_FragColor = vec4(texture2D(gradient,vec2(texture_index,daytime+0.5)).xyz,1.0)*alpha;
}
</script>

<script id="shader-nightday-sprite-v" type="x-shader/x-vertex">
uniform vec2 solar_vector;
uniform mat3 view;
attribute vec2 vertex;
attribute vec3 model_x;
attribute vec3 model_y;
attribute vec3 model_z;
attribute vec3 uv_x;
attribute vec3 uv_y;
attribute vec3 uv_z;
attribute vec3 variant_mask; // Used to access sprite variants
attribute float layer;
varying vec2 uv;
varying float daytime;
varying float layer_level;
varying vec3 mask; // Used to access sprite variants
void main() {
    mat3 model = mat3(model_x,model_y,model_z);
    vec3 pos = model * vec3(vertex,1.0);
    daytime = dot(pos.xy,solar_vector);
    gl_Position = vec4((view*pos).xy,0.5,1.0);
    mask = variant_mask;
    layer_level = layer;
    uv = (mat3(uv_x,uv_y,uv_z) * vec3(vertex,1.0)).xy;
}
</script>

<script id="shader-nightday-sprite-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 uv;
varying float daytime;
uniform sampler2D gradient; // Day/night - layer gradient
uniform sampler2D spritesheet;
varying float layer_level; // Used for the background/foreground color gradient
varying vec3 mask; // Used to access sprite variants
void main() {
    vec4 sheet_color = texture2D(spritesheet,uv);
    float alpha = smoothstep(1.0/3.0, 2.0/3.0, dot(sheet_color.xyz,mask));
    vec3 base_color = texture2D(gradient,vec2(layer_level,daytime+0.5)).xyz;
    gl_FragColor = vec4(base_color*alpha,alpha);
}
</script>

<script id="shader-ui-v" type="x-shader/x-vertex">
attribute vec2 vertex;
attribute vec3 model_x;
attribute vec3 model_y;
attribute vec3 model_z;
attribute vec3 uv_x;
attribute vec3 uv_y;
attribute vec3 uv_z;
attribute float alpha;
varying vec2 uv;
varying float alpha_at_fragment;
uniform mat3 view;

void main() {
    mat3 model = mat3(model_x,model_y,model_z);
    vec2 view_pos = (view * (model * vec3(vertex,1.0))).xy;
    gl_Position = vec4(view_pos,0.5,1.0);
    uv = (mat3(uv_x,uv_y,uv_z) * vec3(vertex,1.0)).xy;
    alpha_at_fragment = alpha;
}
</script>

<script id="shader-ui-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 uv;
varying float alpha_at_fragment;

uniform sampler2D spritesheet;

void main() {
    vec4 tex = texture2D(spritesheet,uv);
    gl_FragColor = tex*alpha_at_fragment;
}
</script>
<script>

// Planet
const PLANET_RADIUS = 24;
const MAN_RADIUS = PLANET_RADIUS-0.02;
const CAMERA_RADIUS = PLANET_RADIUS+0.75;
const MACHINE_RADIUS = PLANET_RADIUS-0.03
const NICE_ZONE_SIZE = 48;
const ZONE_SPEED = 0.03;
const ZONE_STARTING_ANGLE = 0.4; //Radians

// Physics
const GRAVITY = 2;
const PARTICLE_FRICTION = 0.6; // Friction when in contact with planet
const PARTICLE_ELASTICITY = 1.3; // Elasticity off of planet surface

// Man
const MAN_SPEED = 2;
const MAN_WALK_SATISFACTION_RANGE = 0.1;
const MAN_JUMP_VEL = 1.5;
const MAN_INVENTORY_HEIGHT = PLANET_RADIUS*1.013;
const MAN_INVENTORY_BEHIND = 0.20;
const MAN_INVENTORY_FORCE = 8;
const MAN_INVENTORY_DRAG = 0.1;

// Camera
const CAMERA_SPEED = MAN_SPEED*1.2;
const ZOOM_SPEED = 0.05;
const MIN_ZOOM = 0.04;
const MAX_ZOOM = 0.5;

// Items
const ITEM_CLICK_RADIUS = 0.25;
const ITEM_JUMP_FREQUENCY = 3;
const ITEM_JUMP_POWER = 0.3;
const ITEM_SCALE = 0.5;
const ITEM_SLOT_SCALE_SPEED = 8;

// Machines
const ITEM_SLOT_FORCE = 32;
const ITEM_SLOT_DRAG = 0.2;

const MACHINE_SLOT_SPACING = 0.2;
const MACHINE_SLOT_X = 0.6;
const MACHINE_SLOT_Y = 0.3;
const MACHINE_SIZE = 0.6;


const RUNNING_WIGGLE_SPEED = 24;
const RUNNING_WIGGLE_MAGNITUDE = 0.005;
const CONSTRUCTION_ANIM_FRAME_TIME = 0.6;

const MACHINE_CONFIG = {
    'boiler':{
        image: "Machimes/battery-steam.png",
        components: {"metal":2},
        consume_time: 2, // Seconds between each resource consumption
        produce_time: 1, // Seconds between each resource production
        stock: 2,
        consumes: {"water":1},
        produces: {"battery":1},
    },
    'engine':{
        image: "Machimes/battery-combustiom.png",
        components: {"metal":2},
        consume_time: 2, // Seconds between each resource consumption
        produce_time: 1, // Seconds between each resource production
        stock: 2,
        consumes: {"carbon":1},
        produces: {"battery":1},
    },
    'carbon':{
        image: "Machimes/carbom.png",
        components: {"metal":2},
        consume_time: 2, // Seconds between each resource consumption
        produce_time: 1, // Seconds between each resource production
        stock: 2,
        consumes: {"battery":1},
        produces: {"carbon":1},
    },
    'metal':{
        image: "Machimes/metal.png",
        components: {"metal":2},
        consume_time: 2, // Seconds between each resource consumption
        produce_time: 1, // Seconds between each resource production
        stock: 2,
        consumes: {"battery":1},
        produces: {"metal":1},
    },
    'water':{
        image: "Machimes/water.png",
        components: {"metal":2},
        consume_time: 2, // Seconds between each resource consumption
        produce_time: 1, // Seconds between each resource production
        stock: 2,
        consumes: {"battery":1},
        produces: {"water":1},
    },
    'terraformer':{
        image: "Machimes/terraformer.png",
        components: {"metal":8},
        consume_time: 2000000000000, // Seconds between each resource consumption
        produce_time: 2000000000000, // Seconds between each resource production
        stock: 1,
        consumes: {"battery":8},
        produces: {"battery":8},
    },
};

/*
 * A custom render pass that uses the custom shaders
 */
class BackgroundPass extends RenderPass {
    constructor(gl,scene,program,gradient,planet_radius) {
        super(gl,program);
        this.planet_radius = planet_radius;
        this.scene = scene;
        this.gradient = gradient;
        this.vao = new SimpleVAO(gl,program,scene.square_vao);
        this.inverse_view_loc = gl.getUniformLocation(program,"inverse_view");
        this.planet_radius_loc = gl.getUniformLocation(program,"planet_radius");
        this.gradient_loc = gl.getUniformLocation(program,"gradient");
        this.solar_loc = gl.getUniformLocation(program,"solar_vector");
        this.inverse_view = new Mat();
        this.t = 0;
    }
    update(scene,dt) {
        Mat.Inv(this.inverse_view,scene.view);
        this.t += dt;
    }
    draw(gl) {
        gl.useProgram(this.program);
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(this.gradient_loc, 0);
        gl.bindTexture(gl.TEXTURE_2D, this.gradient);
        gl.uniformMatrix3fv(this.inverse_view_loc,false,this.inverse_view.a);
        gl.uniform1f(this.planet_radius_loc,this.planet_radius);
        gl.uniform2fv(this.solar_loc,this.scene.solar_vector.a);
        this.vao.draw(gl);
    }
}

// A builtin pass
class UIPass extends RenderPass{
    constructor(gl,scene,program,texture) {
        super(gl,program);
        this.texture = texture;
        this.dvao = new DynamicVAO(gl,program,scene.square_vao,{
            model: {type:'mat',dynamic:true},
            uv: {type:'mat',dynamic:true},
            alpha: {type:'scalar',dynamic:true},
        },8);
        this.view_loc = gl.getUniformLocation(program,"view");
        this.spritesheet_loc = gl.getUniformLocation(program,"spritesheet");
        this.view = new Mat();
    }
    update(scene,dt) {
        this.view.set(0.25,0.0,0.0,0.25*scene.view.yy/scene.view.xx, 0.0,0.0);
    }
    prepare(gl) {
        this.dvao.prepare(gl);
    }
    draw(gl) {
        gl.useProgram(this.program);
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(this.spritesheet_loc, 0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.uniformMatrix3fv(this.view_loc,false,this.view.a);
        this.dvao.draw(gl);
    }
}

class UISprite{
    constructor(engine,pass,image=null,pos=new Vec(),alpha=1.0) {
        this.engine = engine;
        this.pass = pass;
        this.angle = 0;
        this.scale = 1;
        this.pos = pos;
        this.mirror = false;
        this.data = pass.dvao.acquire(engine.gl);
        this.sprite_matrix = new Mat();
        this.rotation = new Mat();
        this.translation = new Mat();
        this.scaling = new Mat();
        this.setImage(image,alpha);
        this.engine.sprites.add(this);
    }
    destroy() {
        this.pass.dvao.relenquish(this.data);
        this.engine.sprites.delete(this);
    }
    setImage(image,alpha=1.0) {
        this.image = image;
        if (image !== null) {
            if (!this.engine.il.model_frames.has(image)) {
                console.error("Missing image:",image);
            }
            this.sprite_matrix.eq(this.engine.il.model_frames.get(image));
            this.data.uv.eq(this.engine.il.texture_frames.get(image));
            this.data.alpha.set(alpha);
        } else {
            this.sprite_matrix.zeroeq();
            this.data.uv.zeroeq();
            this.data.alpha.zeroeq();
        }
    }
    compute_transform() {
        // Set matrices from values
        this.rotation.rotationeq(this.angle);
        this.translation.translationeq(this.pos);
        if (this.mirror) {
            this.scaling.scalingeq(-this.scale,this.scale);
        } else {
            this.scaling.scalingeq(this.scale,this.scale);
        }
        // Compute model matrix
        this.data.model.eq(this.sprite_matrix);
        this.data.model.composeq(this.scaling);
        this.data.model.composeq(this.rotation);
        this.data.model.composeq(this.translation);
    }
    update(dt) {
        this.compute_transform();
    }
}

class Message extends UISprite {
    constructor(engine,pass,image=null,pos=new Vec(),fadein=0,duration=null,fadeout=0) {
        super(engine,pass,image,pos,0.0);
        this.duration = duration;
        this.fadein = fadein;
        this.duration = duration;
        this.fadeout = fadeout;
        this.age = 0;
    }
    update(dt) {
        this.age += dt;
        let alpha = this.age/this.fadein;
        if (alpha > 1.0) {
            alpha = 1.0;
            if (this.duration) {
                if (this.age > this.duration + this.fadein) {
                    if (this.fadeout > 0) {
                        alpha = 1.0 - (this.age-this.duration-this.fadein)/this.fadeout;
                    }
                    if (this.fadeout === 0 || alpha < 0.0) {
                        alpha = 0.0;
                        this.destroy();
                    }
                }
            }
        }
        this.setImage(this.image,alpha);
        super.update(dt);
    }
}

/* Container class for clickable regions as used by the engine object.*/
class Clickable {
    constructor(x,r,callback) {
        this.x = x;
        this.r = r;
        this.callback = callback;
    }
}
class ArchimedesEngine extends Engine {
    setup() {
        // Clickable region management
        this.clickables = new Set();
        this.click_consumed = false;
        window.addEventListener('mouseup',(e) => this.click_consumed = false);
        window.addEventListener('mousedown',(e) => {
            let nearest = null;
            let nearest_r = null;
            const dr = new Vec();
            for (const clickable of this.clickables) {
                const r = dr.eq(clickable.x).subeq(this.mouse_pos).abs();
                if (r <= clickable.r) {
                    if (nearest_r === null || nearest_r > r) {
                        nearest = clickable;
                        nearest_r = r;
                    }
                }
            }
            if (nearest !== null) {
                nearest.callback();
                this.click_consumed = true;
            } else {
                this.man.setTarget(this.mouse_pos);
            }
        });
        // Background pass
        this.backgroundpass = new BackgroundPass(this.gl,
            this.scene,
            this.sc.programs.get('background'),
            this.il.textures.get('planet_sky'),
            PLANET_RADIUS,
        );
        this.scene.addPass(this.backgroundpass,1.0);
        // Background sprite pass
        this.ndspritepass = new NightdaySpritePass(this.gl,
            this.scene,
            this.sc.programs.get('nightday_sprites'),
            this.il.textures.get('gradient'),
            this.il.textures.get('mountainbiome'),
        );
        this.scene.addPass(this.ndspritepass,0.75);
        // Disc pass
        this.plantdiscpass = new BackgroundPass(this.gl,
            this.scene,
            this.sc.programs.get('planet_disc'),
            this.il.textures.get('planet_sky'),
            PLANET_RADIUS,
        );
        this.scene.addPass(this.plantdiscpass,0.5);
        // Animated sprite pass
        this.aspritepass = new AnimatedSpritePass(this.gl,
            this.scene,
            this.sc.programs.get('nightday_sprites'),
            this.il.textures.get('gradient'),
            this.il.textures.get('animations'),
        );
        this.scene.addPass(this.aspritepass,0.25);
        // Colored overlay sprite class
        this.spritepass = new SpritePass(this.gl,
            this.scene,
            this.sc.programs.get('sprite'),
            this.il.textures.get('animations'),
        );
        this.scene.addPass(this.spritepass,0.125);
        // Top colored overlay sprite class
        this.itempass = new SpritePass(this.gl,
            this.scene,
            this.sc.programs.get('sprite'),
            this.il.textures.get('animations'),
        );
        this.scene.addPass(this.itempass,0.100);
        // UI pass
        this.uipass = new UIPass(this.gl,
            this.scene,
            this.sc.programs.get('ui'),
            this.il.textures.get('animations'),
        );
        this.scene.addPass(this.uipass,0.000);
        
        // Generate background
        function find_layer(map,folder) {
            const names = [];
            for (const [key,value] of map) {
                if (key.includes("/"+folder+"/")) {
                    names.push(key);                
                }
            }
            return names;
        }
        // Set up physics objects
        this.gravity = new ForceNode(
            new Vec(), // center
            GRAVITY, // strength
            0, // drag
            true, // The planet's center never moves
        );
        this.bsprites = find_layer(this.il.model_frames,"Background");
        this.msprites = find_layer(this.il.model_frames,"Midground");
        this.fsprites = find_layer(this.il.model_frames,"Foreground");
        
        // Set zoom control
        window.addEventListener('wheel',(e) => {
            const factor = Math.exp(-0.25*Math.sign(e.deltaY));
            let new_zoom = this.zoom*factor;
            if (new_zoom < MIN_ZOOM) new_zoom = MIN_ZOOM;
            if (new_zoom > MAX_ZOOM) new_zoom = MAX_ZOOM;
            this.zoom_target = new_zoom;
            this.zoom = new_zoom;
        });
        
        this.create();
    }
    buildMachine(type,pos) {
        const stride = this.man.facing().muleq(MACHINE_SIZE);
        pos = pos.clone();
        for (let attempt=0; attempt < 12; ++attempt) {
            pos.addeq(stride);
            pos.normeq().muleq(MACHINE_RADIUS);
            let overlap = false;
            for (const machine of this.machines) {
                if (machine.pos.sub(pos).abs() < MACHINE_SIZE) {
                    overlap = true;
                    break;
                }
            }
            if (!overlap) {
                this.machines.add(new Machine(
                    this,this.aspritepass,pos,type
                ));
                break;
            }
        }
    }
    giveItem(name) {
        new Item(
            this,// engine
            (new Vec()).polareq(PLANET_RADIUS+1.0,0.0), // Pos
            new Vec(1.0,Math.random()-0.5), // Vel
            name, // type
        );
    }
    gen_layer(sprites,layer,rdelta,biomes) {
        let angle = 0;
        while (angle < Math.PI*2.0) {
            const biome = biomes[Math.floor(0.5 * angle / Math.PI * biomes.length)];
            angle += 0.1*Math.random();
            let found = false;
            let name = ""
            for (let attempt=0; attempt<100 && !found; ++attempt) {
                let idx = Math.floor(Math.random()*sprites.length);
                idx = idx >= sprites.length ? sprites.length-1 : idx;
                name = sprites[idx];
                found = !name.includes(biome+"/");
            }
            const flags = Math.floor(Math.random()*7.0+1);
            if (flags < 1) flags = 1;
            if (flags > 7) flags = 7;
            const sprite = new NightdaySprite(this,this.ndspritepass,name,flags,layer);
            sprite.pos.polareq(PLANET_RADIUS+rdelta,angle);
            this.bgsprites.push(sprite);
        }
    }
    message(image,pos=new Vec(0.0,0.5),fadein=0.5,duration=2.0,fadeout=2.0) {
        let title = new Message(
            this,this.uipass,image,
            pos,
            fadein,duration,fadeout
        );
    }
    create() {
        const biomes = ["MountainBiome","AridBiome"];
        this.bgsprites = [];

        this.gen_layer(this.bsprites,0.0,-0.3,biomes);
        this.gen_layer(this.msprites,0.33,-0.2,biomes);
        this.gen_layer(this.fsprites,0.66,-0.1,biomes);
        // Create man 
        this.man = new Man(this,this.aspritepass);
        this.t = 0;
        // Set up camera
        this.camera_pos = new Vec(CAMERA_RADIUS,0.0);
        this.zoom = 0.01;
        this.zoom_target = 0.25;
        this.live_particles = new Set(); // Particles that get simulation updates
        // Machines
        this.machines = new Set();
        // Items
        this.items = new Set();
        for (const name of ['carbon','water','battery','metal','metal']) {
            new Item(
                this,// engine
                (new Vec()).polareq(PLANET_RADIUS+1.0,0.0), // Pos
                new Vec(1.0,Math.random()-0.5), // Vel
                name, // type
            );
        }
        this.message("UI/text-title.png");
    }
    destroy() {
        this.man.destroy();
        for (const s of this.bgsprites) s.destroy();
        this.bgsprites = null;
        for (const m of this.machines) m.destroy();
        this.machines = null;
        for (const i of this.items) i.destroy();
        this.items = null;
        this.ndspritepass.dvao.expunge();
    }
    reset() {
        this.destroy();
        this.create();
    }
    update(dt) {
        super.update(dt);
        this.t += dt;
        // Update physics particles
        for (const p of this.live_particles) {
            p.update(this,dt);
        }
        // Update daytime
        this.scene.solar_vector.polareq(1/NICE_ZONE_SIZE,ZONE_STARTING_ANGLE-Math.PI*0.5-ZONE_SPEED*this.t);
        
        // Camera update
        const dr_target = this.man.target.sub(this.camera_pos);
        const dr_man = this.man.pos.sub(this.camera_pos);
        this.camera_pos.addeq(dr_man.mul(dt*CAMERA_SPEED));
        this.camera_pos.addeq(dr_target.mul(dt*CAMERA_SPEED));
        this.camera_pos.mapabseq((r) => CAMERA_RADIUS);
        this.zoom += ZOOM_SPEED*(this.zoom_target-this.zoom)*dt;
        
        // Build view matrix
        let T = new Mat().translationeq(this.camera_pos.mul(-1));
        let R = new Mat().rotationeq(Math.atan2(this.camera_pos.y,this.camera_pos.x)-Math.PI*0.5);
        let S = new Mat();
        S.a[0] = this.zoom;
        S.a[4] = this.zoom*this.cm.aspectRatio;
        this.scene.view.eq(T);
        Mat.Compose(this.scene.view, R, this.scene.view);
        Mat.Compose(this.scene.view, S, this.scene.view);
    }
}

const engine = new ArchimedesEngine(
    canvas_container = document.getElementById("canvas-container"),
    shader_programs = {
        background:['shader-background-v','shader-background-f'],
        planet_disc:['shader-background-v','shader-planet-disc-f'],
        nightday_sprites:['shader-nightday-sprite-v','shader-nightday-sprite-f'],
        ui:['shader-ui-v','shader-ui-f'],
    },
    images = {
        gradient:'images/gradient.png',
        planet_sky:'images/planet_sky.png',
        mountainbiome:'images/biomes.png',
        animations: 'images/Animations.png',
    },    
    frames = {
        mountainbiome:'images/biomes.json',
        animations: 'images/Animations.json',
    },
    music = {
        //"negentropy": "sound/Chad_Crouch_-_Negentropy.mp3"
    },
    sfx = {
        "stone_walk1": "sounds/stone_walk1.mp3",
        "stone_walk2": "sounds/stone_walk2.mp3",
        "stone_walk3": "sounds/stone_walk3.mp3",
        "stone_walk4": "sounds/stone_walk4.mp3",
        "stone_walk5": "sounds/stone_walk5.mp3",
        "antenna_upload": "sounds/antenna_upload.mp3",
    },
);

</script>

</div>
</body>
</html>
