<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <script src="math32.js"></script>
    <script src="shadercompiler.js"></script>
    <script src="imageloader.js"></script>
    <script src="sounds.js"></script>
    <script src="canvasmanager.js"></script>
    <script src="dynamicvao.js"></script>
    <script src="scene.js"></script>
    <script src="engine.js"></script>
</head>
<body>
<h1>Shadow of Archimedes</h1>
<div id="canvas-container" style="height:80vh; width:100%"></div>

<script id="shader-background-v" type="x-shader/x-vertex">
attribute vec2 vertex;
varying vec2 world_coord;
varying float daytime;
uniform mat3 inverse_view;
uniform vec2 solar_vector;

void main() {
    gl_Position = vec4(vertex,0.0,1.0);
    world_coord = (inverse_view * vec3(vertex,1.0)).xy;
    daytime = dot(world_coord,solar_vector);
}
</script>

<script id="shader-background-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 world_coord;
varying float daytime;
uniform float t;
uniform sampler2D gradient;
void main() {
    gl_FragColor = texture2D(gradient,vec2(24.0-length(world_coord),0.4*daytime+0.5));//vec4(daytime+0.5,0.5,planet_ness, 1.0);
}
</script>

<script id="shader-foreground-f" type="x-shader/x-fragment">
precision highp float;
varying vec2 world_coord;
varying float daytime;
uniform float t;
uniform sampler2D gradient;
void main() {
    gl_FragColor = texture2D(gradient,vec2(4.0-length(world_coord),0.4*daytime+0.5));//vec4(daytime+0.5,0.5,planet_ness, 1.0);
}
</script>
<script>

/*
 * A custom render pass that uses the custom shaders
 */
class BackgroundPass extends RenderPass {
    constructor(gl,scene,program,gradient_texture) {
        super(gl,program);
        this.gradient_texture = gradient_texture;
        this.vao = new SimpleVAO(gl,program,scene.square_vao);
        this.inverse_view_loc = gl.getUniformLocation(program,"inverse_view");
        this.gradient_texture_loc = gl.getUniformLocation(program,"gradient");
        this.t_loc = gl.getUniformLocation(program,"t");
        this.solar_loc = gl.getUniformLocation(program,"solar_vector");
        this.inverse_view = new Mat();
        this.t = 0;
        this.solar_vector = new Vec(1.0,0.0);
    }
    update(scene,dt) {
        Mat.Inv(this.inverse_view,scene.view);
        this.t += dt;
        this.solar_vector.polareq(1/24,-0.2*this.t);
    }
    draw(gl) {
        gl.useProgram(this.program);
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(this.gradient_texture_loc, 0);
        gl.bindTexture(gl.TEXTURE_2D, this.gradient_texture);
        gl.uniformMatrix3fv(this.inverse_view_loc,false,this.inverse_view.a);
        gl.uniform1f(this.t_loc,this.t);
        gl.uniform2fv(this.solar_loc,this.solar_vector.a);
        this.vao.draw(gl);
    }
}

class DemoEngine extends Engine {
    setup() {
        // Background pass
        this.backgroundpass = new BackgroundPass(this.gl,
            this.scene,
            this.sc.programs.get('background'),
            this.il.textures.get('gradient'),
        );
        this.scene.addPass(this.backgroundpass,1.0);
        this.scene.view.translationeq(new Vec(0.0,-24.0));
    }
    update(dt) {
        super.update(dt);
        this.scene.view.a[0] = 1/this.cm.aspectRatio;
    }
}

const engine = new DemoEngine(
    canvas_container = document.getElementById("canvas-container"),
    shader_programs = {
        background:['shader-background-v','shader-background-f']
    },
    images = {
        gradient:'images/gradient_example.png'
    },    
    frames = {
        //spritesheet:'images/hoverbots.json'
    },
    music = {
        //"negentropy": "sound/Chad_Crouch_-_Negentropy.mp3"
    },
    sfx = {
        //"hit": "sound/hit.mp3"
    },
);

</script>

</div>
</body>
</html>
